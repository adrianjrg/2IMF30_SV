% WORKS::           1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, U1
% IN PROGRESS::     7
% REQUIREMENTS STILL TO ADD::
%   - The tether is always connected while the outer door is unlocked and no ship is docked

% REFERENCES
%[true* . b . !a*]<true* a> - if nothing works break glass

% TUESDAY QUESTIONS
%   - R11/R14 equivalance?
%   - is our general form of R2/R9/R12/R13 correct
%   - ask about R7

% R1. Doors will only be unlocked following an appropriate button press.
[!(buttonPressed(bOuter) || buttonPressed(bDashboard))*.unlockDoor(outer)]false         &&
[!(buttonPressed(bInnerStation) || buttonPressed(bInnerBack))*.unlockDoor(inner)]false  &&
[!(buttonPressed(bMiddleMain) || buttonPressed(bMiddleBack))*.unlockDoor(middle)]false

% R2. A door will unlock if and only if both sides have equal pressure.
nu X(pO:Pressure = unpressurized, pM:Pressure = pressurized, pB:Pressure = pressurized, pS:Pressure = pressurized). (
    [spacecraftDocked(true)]X(pressurized, pM, pB, pS)               &&
    [spacecraftDocked(false)]X(unpressurized, pM, pB, pS)            &&
    [setPressure(main, pressurized)]X(pO, pressurized, pB, pS)       &&
    [setPressure(main, unpressurized)]X(pO, unpressurized, pB, pS)   &&
    [setPressure(backup, pressurized)]X(pO, pM, pressurized, pS)     &&
    [setPressure(backup, unpressurized)]X(pO, pM, unpressurized, pS) &&
    [unlockDoor(outer)]val(pM == pO)                                 &&
    [unlockDoor(middle)]val(pM == pB)                                &&
    [unlockDoor(inner)]val(pB == pS)                                 &&
    [!((spacecraftDocked(true)) || spacecraftDocked(false) || setPressure(main, pressurized) || 
        setPressure(main, unpressurized) || setPressure(backup, pressurized) || setPressure(backup, unpressurized))]X(pO, pM, pB, pS) &&
    <true>true
)

% R3. A change in pressure will only occur following a button press.
forall p:Pressure, airL: Airlock.
    [!(buttonPressed(bOuter) || buttonPressed(bDashboard) || buttonPressed(bInnerStation) || buttonPressed(bInnerBack) 
    || buttonPressed(bMiddleMain) || buttonPressed(bMiddleBack))* . setPressure(airL, p)] false

% R4. The main airlock will not be depressurized when an untethered person is present in that airlock.
nu X(perMain:Bool = false, tetherCon:Bool = false). (
    % keep track of person in main airlock and their tethered status
    [personDetected(main, true)]X(true, tetherCon)                  && 
    [personDetected(main, false)]X(false, tetherCon)                &&
    [tetherConnected(true)]X(perMain, true)                         &&
    [tetherConnected(false)]X(perMain, false)                       &&
    
    % when depressurizing main, an unthethered person may not be present 
    [setPressure(main, unpressurized)]val(!(perMain == true && tetherCon == false))       &&

    % all other actions don't change anything
    [!(personDetected(main, true) || tetherConnected(true) || personDetected(main, false) || tetherConnected(false))]X(perMain, tetherCon) &&
    % and no deadlocks
    <true>true
)

% R5. The backup airlock will not depressurize if a person is present.
nu X(perBack:Bool = false). (
    [personDetected(backup, true)]X(true)                  && 
    [personDetected(backup, false)]X(false)                &&
    
    % when depressurizing backup, a person may not be present 
    [setPressure(backup, unpressurized)]val(!perBack)      &&
    
    % all other actions don't change anything
    [!(personDetected(backup, true) || personDetected(backup, false))]X(perBack) &&
    % and no deadlocks
    <true>true
)
% R6. If and only if a spacecraft is docked on the docking station, the dashboard will display a ’Docked’ status.
forall b: Bool.
    [true*.  spacecraftDocked(b). !updateDashboard(docked, b)*]<true*. updateDashboard(docked, b)>true
    
% R7. While any person detector detects a person the dashboard will display an ’Air-lock in use’ status.
forall a1, a2:Airlock.
    [true*.personDetected(a1, true).!updateDashboard(inUse, true)]<true*.updateDashboard(inUse, true)>true &&
    %[true*.personDetected(a1, false).(!personDetected(a1, true))*.personDetected(a2, false)]<true*.updateDashboard(inUse, true)>val(a1 != a2)

% nu X(perMain:Bool = false, perBack:Bool = false). (
%     [personDetected(main, true)]X(true, perBack)                &&
%     [personDetected(main, false)]X(false, perBack)              &&
%     [personDetected(backup, true)]X(perMain, true)              &&
%     [personDetected(backup, false)]X(perMain, false)            &&
  
%     [updateDashboard(inUse, true)]val(perMain || perBack)       &&
%     [updateDashboard(inUse, false)]val(!(perMain || perBack))    &&
      
%     [!(personDetected(main, true) || personDetected(main, false) || personDetected(backup, true) || personDetected(backup, false))]X(perMain, perBack) &&    
%     % no deadlocks
%     <true>true
% )

forall a1, a2: Airlock. 
[true*. personDetected(a1, false).(!personDetected(a1, true))*.personDetected(a2, false)] mu X. nu Y. 
    [!(updateDashboard(inUse, false) || spacecraftDocked(true) || spacecraftDocked(false) || 
        personDetected(backup, true) || personDetected(backup, false) || personDetected(main, true) ||
        personDetected(main, false) || buttonPressed(bOuter) || buttonPressed(bDashboard) || buttonPressed(bMiddleBack) || 
        buttonPressed(bMiddleMain) || buttonPressed(bInnerBack) || buttonPressed(bInnerStation) ||
        tetherConnected(true) || tetherConnected(false) || updateDashboard(docked, false) ||
        updateDashboard(docked, true) || updateDashboard(inUse, true) || tau)]X && 

    [spacecraftDocked(true) || spacecraftDocked(false) || personDetected(backup, true) 
        || personDetected(backup, false) || personDetected(main, true) || personDetected(main, false) 
        || buttonPressed(bOuter) || buttonPressed(bDashboard) || buttonPressed(bMiddleBack) || buttonPressed(bMiddleMain)  
        || buttonPressed(bInnerBack) || buttonPressed(bInnerStation) || tetherConnected(true)
        || tetherConnected(false) || updateDashboard(docked, false) || updateDashboard(docked, true) || updateDashboard(inUse, true) || tau]Y && <true>true



% R8. An operator can request to open the outer door with a dashboard button if and only if there is a spacecraft docked.
[true*.updateDashboard(docked, false). !updateDashboard(docked,true)* . buttonPressed(bDashboard)]false

% R9. An airlock will not change pressure unless both adjacent doors are locked.
nu X(dO: DoorStatus = lock, dM: DoorStatus = lock, dI: DoorStatus = lock).(
    % keep track of doorstatus during operation
    [unlockDoor(inner)]X(dO, dM, unlock)            &&
    [unlockDoor(middle)]X(dO, unlock, dI)           &&
    [unlockDoor(outer)]X(unlock, dM, dI)            &&
    
    [doorState(inner, lock)]X(dO, dM, lock)         &&
    [doorState(middle, lock)]X(dO, lock, dI)        &&
    [doorState(outer, lock)]X(lock, dM, dI)         &&

    [doorState(outer, noreply)]X(noreply, dM, dI)   &&
    
    [forall p:Pressure. setPressure(main, p)](val(dO == lock && dM == lock))        &&
    [forall p:Pressure. setPressure(backup, p)](val(dM == lock && dI == lock))      &&
    % all other actions don't change anything
    [ !(unlockDoor(inner) || unlockDoor(middle) || unlockDoor(outer) || doorState(inner, lock) || 
        doorState(middle, lock) || doorState(outer, lock) || doorState(outer, noreply)) ]X(dO, dM, dI) &&
    % no deadlocks
    <true>true
)

% R10. If and only if the outer door fails, the dashboard will display an ’Alarm’ status.
[true*. doorState(outer, noreply). !updateDashboard(alarm, true)*]<true*. updateDashboard(alarm, true)>true

% R11. You can not press a button immediately following another button press (some processes must take place in between). 
% forall b1, b2:Button.
%     [true*.buttonPressed(b1)]<buttonPressed(b2)>false
% attempt to make is go faster - TODO: why are they not equivalent?
[true*.forall b1:Button.buttonPressed(b1)]<forall b2:Button. buttonPressed(b2)>false

% R12. The tether sensor will not change readings if : no person is present in the main airlock - and the outer door is unlocked.
    [personDetected(main, true)]X(true, dO)             &&
    [personDetected(main, false)]X(false, dO)           &&
    
    [unlockDoor(outer)]X(perMain, unlock)               &&
    [doorState(outer, noreply)]X(perMain, noreply)      &&
    [doorState(outer, lock)]X(perMain, lock)            &&

    [forall b:Bool. tetherConnected(b)]val(perMain == true && dO != unlock)    &&
    
    [ !(personDetected(main, true) || personDetected(main, false) || unlockDoor(outer) || doorState(outer, noreply) ||
        doorState(outer, lock)) ]X(perMain, dO) &&
    <true>true
)

% R13. Person detector may change readings if at least one of the two adjacent doors is unlocked.
nu X(dO: DoorStatus = lock, dM: DoorStatus = lock, dI: DoorStatus = lock).(
    [unlockDoor(inner)]X(dO, dM, unlock)            &&
    [unlockDoor(middle)]X(dO, unlock, dI)           &&
    [unlockDoor(outer)]X(unlock, dM, dI)            &&
    
    [doorState(inner, lock)]X(dO, dM, lock)         &&
    [doorState(middle, lock)]X(dO, lock, dI)        &&
    [doorState(outer, lock)]X(lock, dM, dI)         &&

    [doorState(outer, noreply)]X(noreply, dM, dI)   &&


    [forall b:Bool. personDetected(main, b)](val(dO == unlock || dM == unlock))        &&
    [forall b:Bool. personDetected(backup, b)](val(dM == unlock || dI == unlock))      &&
    
    
    [ !(unlockDoor(inner) || unlockDoor(middle) || unlockDoor(outer) || doorState(inner, lock) || 
        doorState(middle, lock) || doorState(outer, lock) || doorState(outer, noreply))]X(dO, dM, dI) &&
    
    <true>true
)

% R14. After a button is pressed, eventually another button can be pressed.
forall b2: Button.
    [true*. forall b1: Button. buttonPressed(b1). !buttonPressed(b2)*]<true*.buttonPressed(b2)>true

% R15. Once the outer door fails, the pressure in the main airlock should not be changed. FAILED
forall p:Pressure.
    [true*. doorState(outer, noreply). !setPressure(main, p)* .setPressure(main, p)]false

% Sanity checks
% U1. If the outer door fails and there is a person present in the main airlock, eventually the middle door will be able to unlock.
[!buttonPressed(bDashboard)*. doorState(outer, noreply)]<!buttonPressed(bDashboard)*. doorState(middle,unlock)>true